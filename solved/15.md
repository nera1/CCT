# 배달

[배달](https://school.programmers.co.kr/learn/courses/30/lessons/12978)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ✅   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/challenges)
- Difficulty : Lv.2
- Algorithm : Dynamic Programming
- Taken : 1h
- Rate : 50%

## Solution

```JAVA
import java.util.*;
class Solution {
    private int max = 6000000;
    public int solution(int N, int[][] road, int K) {
        int answer = 0;
        int[][] dp = new int[2*N][2*N];
        for(int[] line : dp) {
            Arrays.fill(line, max);
        }
        for(int[] r : road) {
            int from = r[0];
            int to = r[1];
            int dist = r[2];
            dp[from][to] = (int)Math.min(dp[from][to], dist);
            dp[to][from] = dp[from][to];
        }
        for(int i = 1; i<= N; i++) {
            dp[i][i] = 0;
        }
        for(int i = 1; i <= N; i++) {
            for(int j = 1; j <= N; j++) {
                for(int k = 1; k <= N; k++) {
                    if(i == k || k == j) {
                        continue;
                    }
                    int newDist = dp[i][k] + dp[k][j];
                    dp[i][j] = (int)Math.min(dp[i][j], newDist >= max ? max : newDist);
                    dp[j][i] = dp[i][j];
                }
            }
        }
        for(int i = 1;i<=N;i++) {
            for(int j=1;j<=N;j++) {
                int newDist = dp[1][j] + dp[j][i];
                dp[1][i] = (int)Math.min(dp[1][i], newDist >= max ? max : newDist);
            }
        }
        for(int i = 1; i <= N; i++) {
            if(dp[1][i] <= K) {
                answer++;
            }
        }
        return answer;
    }
}
```

- 최소 거리를 계산하는 과정에서 대칭이 안 맞을수가 있다
    - i to j 거리가 갱신되었는데, j to i 거리가 갱신되지 않는 경우가 발생
    - 방향이 없는 그래프라 거리가 갱신 될 때마다 대칭되는 부분도 갱신
- 배열 초기화 시 Integer.MAX_VALUE 쓰면 오버플로우 발생 가능성 있음
    - 최대 숫자가 주어지거나 계산 가능하면 그것으로 배열을 초기화 해야 함
