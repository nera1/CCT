# 행렬 테두리 회전하기

[행렬 테두리 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/77485)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ✅   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/challenges)
- Difficulty : Lv.2
- Algorithm : Implementation
- Taken : 2h
- Rate : 48%

## Solution

```JAVA
import java.util.*;
class Solution {
    private int rotate(int[][] table, int[] query) {
        int min = table.length * table[0].length;
        Queue<Integer> queue = new LinkedList<>();
        int[] start = new int[]{query[0] - 1, query[1] - 1};
        int[] end = new int[]{query[2] - 1, query[3] - 1};
        Queue<String> path = new LinkedList<>();
        for(int i = start[1];i<end[1];i++) {
            int j = start[0];
            int v = table[j][i];
            String pair = j + "_" + i;
            path.add(pair);
            queue.add(v);
        }
        for(int i = start[0];i<end[0];i++) {
            int j = end[1];
            int v = table[i][j];
            String pair = i + "_" + j;
            path.add(pair);
            queue.add(v);
        }
        for(int i = end[1];i>start[1];i--) {
            int j = end[0];
            int v = table[j][i];
            String pair = j + "_" + i;
            path.add(pair);
            queue.add(v);
        }
        for(int i = end[0];i>start[0];i--) {
            int j = start[1];
            int v = table[i][j];
            String pair = i + "_" + j;
            path.add(pair);
            queue.add(v);
        }
        String[] last = path.poll().split("_");
        while(path.size() > 0) {
            String[] rc = path.poll().split("_");
            int r = Integer.parseInt(rc[0]);
            int c = Integer.parseInt(rc[1]);
            int v = queue.poll();
            table[r][c] = v;
            if(v < min) {
                min = v;
            }
        }
        int r = Integer.parseInt(last[0]);
        int c = Integer.parseInt(last[1]);
        if(queue.peek() < min) {
            min = queue.peek();
        }
        table[r][c] = queue.poll();
        return min;
    }
    private void init(int[][] table) {
        int m = 1;
        for(int i = 0; i < table.length; i++) {
            for(int j = 0; j < table[i].length; j++) {
                table[i][j] = m++;
            }
        }
    }
    public int[] solution(int rows, int columns, int[][] queries) {
        int[] answer = new int[queries.length];
        int[][] table = new int[rows][columns];
        int[][] compare = new int[rows][columns];
        init(table);
        int idx = 0;
        for(int[] q: queries) {
            int val = rotate(table, q);
            answer[idx++] = val;
        }
        return answer;
    }
}
```

- 배열을 순회하며 직접 옮기는 식으로 하니 오류도 잦고 예외처리도 많다

  1. 제대로 순회하는 방법을 찾고
  2. 순회할 때 순회하는 좌표(row, col)와 그 값을 Queue에 넣고
  3. 값들을 Queue에서 빼내면서 회전시킨다

- 처음 2차원 배열을 정수로 초기화 할 떄 
