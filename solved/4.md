# 연속된 부분 수열의 합

[연속된 부분 수열의 합](https://school.programmers.co.kr/learn/courses/30/lessons/178870)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ✅   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/challenges)
- Difficulty : Lv.2
- Algorithm : Two-Pointer
- Taken : 2h
- Rate : 53%

## Solution

```JAVA
import java.util.*;
class Solution {
    public int[] solution(int[] sequence, int k) {
        int[] answer = {};
        int start = 0;
        int end = sequence.length - 1;
        int sum = 0;
        for(int num : sequence) {
            sum += num;
        }
        int min = sequence.length;
        int aStart = start;
        int aEnd = end;
        while(true) {
            if(sum == k) {
                if(end - start + 1 < min) {
                    min = end - start + 1;
                    aStart = start;
                    aEnd = end;
                }
            }
            if(sum - sequence[end] < k) {
                break;
            } else {
                sum -= sequence[end--];
            }
        }

        while(end < sequence.length) {
            while(start <= end) {
                if(sum - sequence[start] < k) {
                    break;
                } else if (sum - sequence[start] > k) {
                    sum -= sequence[start++];
                } else {
                    if(end - (start + 1) + 1 < min) {
                        sum -= sequence[start++];
                        min = end - start + 1;
                        aStart = start;
                        aEnd = end;
                    } else if(end - (start + 1) + 1 == min) {
                        if(start + 1 < aStart) {
                            sum -= sequence[start++];
                            aStart = start;
                            aEnd = end;
                        }
                    }
                    break;
                }
            }
            if(end + 1 >= sequence.length) {
                break;
            }
            sum += sequence[++end];
        }

        return new int[]{aStart ,aEnd};
    }
}
```

- 배열에서 어떠한 구간을 찾는 문제는 투 포인터 알고리즘 적용 가능성이 있음
- 투 포인터 알고리즘 문제를 풀면서 슬라이딩 윈도우를 사용하지 않아 코드가 복잡해지고 예외처리가 어려워진다

```JAVA
class Solution {
    public int[] solution(int[] sequence, int k) {
        int start = 0;
        int end = 0;
        int sum = sequence[0];
        int minLength = Integer.MAX_VALUE;
        int aStart = 0;
        int aEnd = 0;

        while (end < sequence.length) {
            if (sum == k) {
                // 더 짧은 길이의 부분 수열을 발견한 경우
                if (end - start < minLength) {
                    minLength = end - start;
                    aStart = start;
                    aEnd = end;
                }
                // 윈도우 시작점을 이동하여 길이 줄이기
                sum -= sequence[start++];
            } else if (sum < k) {
                // 합이 작으므로 윈도우 끝점을 확장
                if (++end < sequence.length) {
                    sum += sequence[end];
                }
            } else {
                // 합이 크므로 윈도우 시작점을 이동
                sum -= sequence[start++];
            }
        }

        return new int[]{aStart, aEnd};
    }
}

```

- 시작점과 끝 점을 같게 적용
- 조건에 따라 시작점 또는 끝 점을 이동
- 문제 조건에서 구간의 길이가 같을 경우 시작점이 앞선 구간을 우선한다고 하였으나 솔루션에서 해당 조건을 따로 검사하지 않는 이유

슬라이딩 윈도우의 특성상 자연스럽게 가장 앞에 있는 구간이 선택되기 때문입니다.

슬라이딩 윈도우 기법에서 end 포인터가 오른쪽으로 확장되며 start 포인터가 필요에 따라 이동하므로, 다음과 같은 결과가 보장됩니다

1. 가장 먼저 발견된 부분 수열이 항상 가장 앞에 있는 구간이 됩니다.
2. 코드에서 합이 k와 같아지는 경우, 현재 구간 길이를 체크하여 minLength와 비교합니다. 이때 가장 앞에 있는 구간을 먼저 찾고 업데이트합니다.
3. 이후 같은 길이의 다른 구간이 나오더라도 minLength와 비교할 때 이미 최소 길이를 만족하는 첫 번째 구간의 시작점을 기록했으므로 업데이트되지 않습니다.

슬라이딩 윈도우 기법으로 구현하면, 조건에 맞는 첫 번째 구간이 가장 앞선 구간이기 때문에 별도의 추가 조건 없이 자동으로 "시작점이 앞선 구간 우선" 규칙이 만족됩니다.
