# 이모티콘 할인행사

[이모티콘 할인행사](https://school.programmers.co.kr/learn/courses/30/lessons/150368)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ✅   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/challenges)
- Difficulty : Lv.2
- Algorithm : Brute Force
- Taken : 50m
- Rate : 39%

## Solution

```JAVA
import java.util.*;
class Solution {
    private PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{
        if(a[0] != b[0]) {
            return b[0] - a[0];
        } else {
            return b[1] - a[1];
        }
    });
    public int[] answer = new int[2];
    public Map mapGen(String r) {
        String[] arr = r.split(" ");
        Map<Integer, Set> map = new HashMap<>();
        for(String item : arr) {
            String[] i = item.split("_");
            int key = Integer.parseInt(i[1]);
            int value = Integer.parseInt(i[0]);
            if(map.get(key) == null) {
                Set<Integer> set = new HashSet<>();
                set.add(value);
                map.put(key, set);
            } else {
                map.get(key).add(value);
            }
        }
        return map;
    }
    public void recursive(int[][] table, int depth, String result, int[][] users) {
        if(depth == table.length) {
            result = result.trim();
            Map<Integer, Set> map = mapGen(result);
            int sub = 0;
            int cost = 0;
            for(int[] user : users) {
                int cri = user[0];
                int limit = user[1];
                int sum = 0;
                for(Integer rate : map.keySet()) {
                    if(rate >= cri) {
                        Set<Integer> s = map.get(rate);
                        for(int p : s) {
                            sum += p;
                        }
                    }
                }
                if(sum >= limit) {
                    sub++;
                } else {
                    cost += sum;
                }
            }
            pq.add(new int[]{sub, cost});
        } else {
            for(int i = 0; i < table[depth].length;i++) {
                recursive(table, depth + 1, result + " " + table[depth][i] + "_" + 10*(i+1) ,users);
            }
        }
    }
    public int[] solution(int[][] users, int[] emoticons) {
        int[][] table = new int[emoticons.length][4];
        for(int i = 0; i < table.length; i++) {
            for(int j = 0; j < 4; j++) {
                int val = emoticons[i];
                table[i][j] = val*(100 - (j + 1) * 10)/100;
            }
        }
        recursive(table, 0, "", users);
        return pq.poll();
    }
}
```

- 이모티콘의 수가 매우 적어 전체 경우를 따져볼 만 하다
- 너무 많은 요소를 고려해야할 때 방법이 잘 떠오르지 않는 문제는 완전탐색을 시도한다
