# 리코쳇 로봇

[리코쳇 로봇](https://school.programmers.co.kr/learn/courses/30/lessons/169199)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ✅   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/challenges)
- Difficulty : Lv.2
- Algorithm : BFS
- Taken : 32m
- Rate : 47%

## Solution

```JAVA
import java.util.*;

class Solution {
    private String[][] gameBoard (String[] arr) {
        String[][] board = new String[arr.length][arr[0].length()];
        for(int i = 0; i < board.length; i++) {
            board[i] = arr[i].split("");
        }
        return board;
    }
    private int[] mover(int[] currentPos,int[] direction, String[][] gameMap) {
        int[] pos = new int[]{currentPos[0], currentPos[1]};
        while(true) {
            int newI = pos[0] + direction[0];
            int newJ = pos[1] + direction[1];
            if(newI < 0 ||
               newJ < 0 ||
               newI >= gameMap.length ||
               newJ >= gameMap[0].length ||
               (gameMap[newI][newJ].equals("D"))) {
                break;
            }
            pos[0] = newI;
            pos[1] = newJ;
        }
        return pos;
    }
    public int solution(String[] board) {
        int answer = 0;
        String[][] b = gameBoard(board);
        int[] start = new int[2];
        int[] goal = new int[2];
        for(int i = 0; i < b.length; i++) {
            for(int j = 0; j < b[i].length; j++) {
                if(b[i][j].equals("R")) {
                    start[0] = i;
                    start[1] = j;
                }
                if(b[i][j].equals("G")) {
                    goal[0] = i;
                    goal[1] = j;
                }
            }
        }
        Queue<int[]> queue = new LinkedList<>();
        int[][] move = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
        int min = Integer.MAX_VALUE;

        queue.add(new int[]{start[0], start[1], 0});
        Set<String> check = new HashSet<>();
        check.add(start[0] + "_" + start[1]);

        while(queue.size() > 0) {
            int[] current = queue.poll();
            int depth = current[2];
            if(depth > min) {
                continue;
            }
            if(current[0] == goal[0] && current[1] == goal[1]) {
                if(depth < min) {
                    min = depth;
                    continue;
                }
            }
            for(int[] m : move) {
                int[] newPos = mover(current, m, b);
                if(check.contains(newPos[0] + "_" + newPos[1])) {
                    continue;
                }
                queue.add(new int[]{newPos[0], newPos[1], current[2] + 1});
                check.add(newPos[0] + "_" + newPos[1]);
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min;
    }
}
```

- 일반적인 BFS 문제
