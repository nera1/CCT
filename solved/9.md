# 혼자서 하는 틱택토

[혼자서 하는 틱택토](https://school.programmers.co.kr/learn/courses/30/lessons/160585)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ✅   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/challenges)
- Difficulty : Lv.2
- Algorithm : DFS
- Taken : 2h
- Rate : 39%

```JAVA
class Solution {
    private int answer = 0;
    private String arrToStr(String[][] arr) {
        String s = "";
        for(int i = 0; i < arr.length; i++) {
            for(int j = 0; j < arr[i].length; j++) {
                s += arr[i][j].isBlank() ? "." : arr[i][j];
            }
        }
        return s;
    }
    private boolean checkComplete(String[][] temp) {
        for(int i = 0; i < temp.length; i++) {
            // 가로
            String s = temp[i][0];
            boolean f = true;
            for(int j = 0; j < temp[i].length; j++) {
                if(!s.equals(temp[i][j])) {
                    f = false;
                    break;
                }
            }
            if(!s.equals("") && f) {
                return true;
            }
        }
        for(int i = 0; i < temp[0].length; i++) {
            // 세로
            String s = temp[0][i];
            boolean f = true;
            for(int j = 0; j < temp.length; j++) {
                if(!s.equals(temp[j][i])) {
                    f = false;
                    break;
                }
            }
            if(!s.equals("") && f) {
                return true;
            }
        }
        String s = temp[0][0];
        boolean f = true;
        for(int i = 0; i < temp.length; i++) {
            // 대각1
            if(!s.equals(temp[i][i])) {
                f = false;
                break;
            }
        }
        if(!s.equals("") && f) {
            return true;
        }

        int m = temp[0].length - 1;
        s = temp[0][m];
        f = true;

        for(int i = 0; i < temp.length; i++) {
            // 대각2
            if(!s.equals(temp[i][m - i])) {
                f = false;
                break;
            }
        }
        if(!s.equals("") && f) {
            return true;
        }
        return false;
    }
    private void recursive(String[][] temp,
                           Set<String> check,
                           String start,
                           Set<String> mapSet) {
                if(checkComplete(temp)) {
                    String comS = arrToStr(temp);
                    mapSet.add(comS);
                } else {
                    for(int i = 0; i < temp.length; i++) {
                        for(int j = 0; j < temp[i].length; j++) {
                            if(check.contains(i + "_" + j)) {
                                continue;
                            } else {
                                String tStr = arrToStr(temp);
                                mapSet.add(tStr);
                                if(tStr.equals("....X....")) {
                                    System.out.println("HERE");
                                }
                                String next = start.equals("O") ? "X" : "O";
                                temp[i][j] = next;
                                String cStr = i + "_" + j;
                                check.add(cStr);
                                recursive(temp, check, next, mapSet);
                                check.remove(cStr);
                                temp[i][j] = "";
                            }
                        }
                    }
                }
    }
    public int solution(String[] board) {
        String[][] gb = new String[board.length][board[0].length()];
        String[][] temp = new String[board.length][board[0].length()];
        for(int i = 0; i < gb.length; i++) {
            gb[i] = board[i].split("");
        }
        for(int j = 0; j < temp.length; j++) {
            Arrays.fill(temp[j], "");
        }
        Set<String> check = new HashSet<>();
        Set<String> mapSet = new HashSet<>();
        recursive(temp, check, "X", mapSet);
        String comp = "";
        for(int i = 0; i < board.length; i++) {
            comp += board[i];
        }
        if(mapSet.contains(comp)) {
            return 1;
        } else {
            return 0;
        }
    }
}
```

- 틱택토의 경우 모든 경우의 수를 다해도 그 수가 적어 모든 결과를 구하는 방식으로 해결
- 문제에서 선공은 'O'로 시작한다고 했으나 그것을 간과하여 'X' 선공의 경우까지 구하여 많은 시간 소요
