# 부대 복귀

[부대 복귀](https://school.programmers.co.kr/learn/courses/30/lessons/132266)

## Review

| Date  | Solved |
| :---: | :----: |
| First |   ❌   |

## Overview

- Language : JAVA
- Platform : [Programmers](https://school.programmers.co.kr/learn/courses)
- Difficulty : Lv.3
- Algorithm : BFS
- Taken : 1d
- Rate : 45%

## Solution

- 다익스트라 알고리즘 수행

  - N \* N 배열을 선언하자 메모리 초과

- BFS 수행

  - sources 배열의 원소를 순회 하며 최단거리 계산
  - N \* N 크기의 배열을 선언할 수 없어 Map에 최단거리 저장
  - 원소마다 BFS를 실행하여 시간 초과 발생

- BFS 수행 2
  - 양방향 그래프에서, 시작점이 여러개고 destination이 고정이다
    - destination에서 출발하여 각 시작점으로 이동하는 경로를 구하면 한번의 BFS로 모든 거리 계산 가능
    - 이미 지나간 지점은 다시 지나가지 않도록 체크해야 시간 준수 가능

```java
import java.util.*;

class Solution {
    public int[] BFS(Map<Integer,Set> map, int start, Set<Integer> resources, int n, int[] sources) {
        int[] answer = new int[resources.size()];
        Map<Integer, Integer> min = new HashMap<>();
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{start, 0});
        Set<Integer> check = new HashSet<>();
        while(queue.size() > 0) {
            int[] item = queue.poll();
            int p = item[0];
            int d = item[1];
            Integer minVal = min.get(p);
            if(d > n) {
                continue;
            }
            if(resources.contains(p)) {
                Integer prev = min.get(p);
                if(prev == null) {
                    min.put(p, d);
                } else {
                    min.put(p, Math.min(prev, d));
                }
            }
            Set<Integer> nexts = (Set<Integer>)map.get(p);
            if(nexts == null) {
                continue;
            }
            for(int p2 : nexts) {
                if(!check.contains(p2)) {
                    check.add(p2);
                    queue.add(new int[]{p2, d + 1});
                }
            }
        }
        int idx = 0;
        for(int a : sources) {
            Integer val = min.get(sources[idx]);
            if(val == null) {
                answer[idx++] = -1;
            } else {
                answer[idx++] = val;
            }
        }
        return answer;
    }
    public int[] solution(int n, int[][] roads, int[] sources, int destination) {
        int[] answer = new int[sources.length];
        Map<Integer, Set> map = new HashMap<>();
        for(int[] road : roads) {
            int s = road[0];
            int e = road[1];
            Set<Integer> s1 = new HashSet<>();
            s1.add(s);
            Set<Integer> s2 = new HashSet<>();
            s2.add(e);
            Set<Integer> t1 = (Set<Integer>)map.get(s);
            Set<Integer> t2 = (Set<Integer>)map.get(e);
            if(t1 == null) {
                map.put(s, s2);
            } else {
                t1.add(e);
            }
            if(t2 == null) {
                map.put(e, s1);
            } else {
                t2.add(s);
            }
        }
        Set<Integer> sset = new HashSet<>();
        for(int s : sources) {
            sset.add(s);
        }
        return BFS(map, destination, sset, n, sources);
    }
}
```
